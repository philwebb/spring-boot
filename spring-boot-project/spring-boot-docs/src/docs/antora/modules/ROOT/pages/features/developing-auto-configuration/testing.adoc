[[features.developing-auto-configuration.testing]]
= Testing your Auto-configuration

An auto-configuration can be affected by many factors: user configuration (`@Bean` definition and `Environment` customization), condition evaluation (presence of a particular library), and others.
Concretely, each test should create a well defined `ApplicationContext` that represents a combination of those customizations.
`ApplicationContextRunner` provides a great way to achieve that.

`ApplicationContextRunner` is usually defined as a field of the test class to gather the base, common configuration.
The following example makes sure that `MyServiceAutoConfiguration` is always invoked:

include::code:MyServiceAutoConfigurationTests[tag=runner]

TIP: If multiple auto-configurations have to be defined, there is no need to order their declarations as they are invoked in the exact same order as when running the application.

Each test can use the runner to represent a particular use case.
For instance, the sample below invokes a user configuration (`UserConfiguration`) and checks that the auto-configuration backs off properly.
Invoking `run` provides a callback context that can be used with `AssertJ`.

include::code:MyServiceAutoConfigurationTests[tag=test-user-config]

It is also possible to easily customize the `Environment`, as shown in the following example:

include::code:MyServiceAutoConfigurationTests[tag=test-env]

The runner can also be used to display the `ConditionEvaluationReport`.
The report can be printed at `INFO` or `DEBUG` level.
The following example shows how to use the `ConditionEvaluationReportLoggingListener` to print the report in auto-configuration tests.

include::code:MyConditionEvaluationReportingTests[]



[[features.developing-auto-configuration.testing.simulating-a-web-context]]
== Simulating a Web Context
If you need to test an auto-configuration that only operates in a servlet or reactive web application context, use the `WebApplicationContextRunner` or `ReactiveWebApplicationContextRunner` respectively.



[[features.developing-auto-configuration.testing.overriding-classpath]]
== Overriding the Classpath
It is also possible to test what happens when a particular class and/or package is not present at runtime.
Spring Boot ships with a `FilteredClassLoader` that can easily be used by the runner.
In the following example, we assert that if `MyService` is not present, the auto-configuration is properly disabled:

include::code:../MyServiceAutoConfigurationTests[tag=test-classloader]



