[[data.sql.datasource]]
= Configure a DataSource

Java's `javax.sql.DataSource` interface provides a standard method of working with database connections.
Traditionally, a `DataSource` uses a `URL` along with some credentials to establish a database connection.

TIP: See <<howto#howto.data-access.configure-custom-datasource,the "`How-to`" section>> for more advanced examples, typically to take full control over the configuration of the DataSource.



[[data.sql.datasource.embedded]]
== Embedded Database Support
It is often convenient to develop applications by using an in-memory embedded database.
Obviously, in-memory databases do not provide persistent storage.
You need to populate your database when your application starts and be prepared to throw away data when your application ends.

TIP: The "`How-to`" section includes a <<howto#howto.data-initialization, section on how to initialize a database>>.

Spring Boot can auto-configure embedded https://www.h2database.com[H2], https://hsqldb.org/[HSQL], and https://db.apache.org/derby/[Derby] databases.
You need not provide any connection URLs.
You need only include a build dependency to the embedded database that you want to use.
If there are multiple embedded databases on the classpath, set the configprop:spring.datasource.embedded-database-connection[] configuration property to control which one is used.
Setting the property to `none` disables auto-configuration of an embedded database.

[NOTE]
====
If you are using this feature in your tests, you may notice that the same database is reused by your whole test suite regardless of the number of application contexts that you use.
If you want to make sure that each context has a separate embedded database, you should set `spring.datasource.generate-unique-name` to `true`.
====

For example, the typical POM dependencies would be as follows:

[source,xml,indent=0,subs="verbatim"]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-jpa</artifactId>
	</dependency>
	<dependency>
		<groupId>org.hsqldb</groupId>
		<artifactId>hsqldb</artifactId>
		<scope>runtime</scope>
	</dependency>
----

NOTE: You need a dependency on `spring-jdbc` for an embedded database to be auto-configured.
In this example, it is pulled in transitively through `spring-boot-starter-data-jpa`.

TIP: If, for whatever reason, you do configure the connection URL for an embedded database, take care to ensure that the database's automatic shutdown is disabled.
If you use H2, you should use `DB_CLOSE_ON_EXIT=FALSE` to do so.
If you use HSQLDB, you should ensure that `shutdown=true` is not used.
Disabling the database's automatic shutdown lets Spring Boot control when the database is closed, thereby ensuring that it happens once access to the database is no longer needed.



[[data.sql.datasource.production]]
== Connection to a Production Database
Production database connections can also be auto-configured by using a pooling `DataSource`.



[[data.sql.datasource.configuration]]
== DataSource Configuration
DataSource configuration is controlled by external configuration properties in `+spring.datasource.*+`.
For example, you might declare the following section in `application.properties`:

[source,yaml,indent=0,subs="verbatim",configprops,configblocks]
----
	spring:
	  datasource:
	    url: "jdbc:mysql://localhost/test"
	    username: "dbuser"
	    password: "dbpass"
----

NOTE: You should at least specify the URL by setting the configprop:spring.datasource.url[] property.
Otherwise, Spring Boot tries to auto-configure an embedded database.

TIP: Spring Boot can deduce the JDBC driver class for most databases from the URL.
If you need to specify a specific class, you can use the configprop:spring.datasource.driver-class-name[] property.

NOTE: For a pooling `DataSource` to be created, we need to be able to verify that a valid `Driver` class is available, so we check for that before doing anything.
In other words, if you set `spring.datasource.driver-class-name=com.mysql.jdbc.Driver`, then that class has to be loadable.

See {spring-boot-autoconfigure-module-code}/jdbc/DataSourceProperties.java[`DataSourceProperties`] for more of the supported options.
These are the standard options that work regardless of <<features#data.sql.datasource.connection-pool, the actual implementation>>.
It is also possible to fine-tune implementation-specific settings by using their respective prefix (`+spring.datasource.hikari.*+`, `+spring.datasource.tomcat.*+`, `+spring.datasource.dbcp2.*+`, and `+spring.datasource.oracleucp.*+`).
See the documentation of the connection pool implementation you are using for more details.

For instance, if you use the {tomcat-docs}/jdbc-pool.html#Common_Attributes[Tomcat connection pool], you could customize many additional settings, as shown in the following example:

[source,yaml,indent=0,subs="verbatim",configprops,configblocks]
----
	spring:
	  datasource:
	    tomcat:
	      max-wait: 10000
	      max-active: 50
	      test-on-borrow: true
----

This will set the pool to wait 10000ms before throwing an exception if no connection is available, limit the maximum number of connections to 50 and validate the connection before borrowing it from the pool.



[[data.sql.datasource.connection-pool]]
== Supported Connection Pools
Spring Boot uses the following algorithm for choosing a specific implementation:

. We prefer https://github.com/brettwooldridge/HikariCP[HikariCP] for its performance and concurrency.
If HikariCP is available, we always choose it.
. Otherwise, if the Tomcat pooling `DataSource` is available, we use it.
. Otherwise, if https://commons.apache.org/proper/commons-dbcp/[Commons DBCP2] is available, we use it.
. If none of HikariCP, Tomcat, and DBCP2 are available and if Oracle UCP is available, we use it.

NOTE: If you use the `spring-boot-starter-jdbc` or `spring-boot-starter-data-jpa` "`starters`", you automatically get a dependency to `HikariCP`.

You can bypass that algorithm completely and specify the connection pool to use by setting the configprop:spring.datasource.type[] property.
This is especially important if you run your application in a Tomcat container, as `tomcat-jdbc` is provided by default.

Additional connection pools can always be configured manually, using `DataSourceBuilder`.
If you define your own `DataSource` bean, auto-configuration does not occur.
The following connection pools are supported by `DataSourceBuilder`:

* HikariCP
* Tomcat pooling `Datasource`
* Commons DBCP2
* Oracle UCP & `OracleDataSource`
* Spring Framework's `SimpleDriverDataSource`
* H2 `JdbcDataSource`
* PostgreSQL `PGSimpleDataSource`
* C3P0



[[data.sql.datasource.jndi]]
== Connection to a JNDI DataSource
If you deploy your Spring Boot application to an Application Server, you might want to configure and manage your DataSource by using your Application Server's built-in features and access it by using JNDI.

The configprop:spring.datasource.jndi-name[] property can be used as an alternative to the configprop:spring.datasource.url[], configprop:spring.datasource.username[], and configprop:spring.datasource.password[] properties to access the `DataSource` from a specific JNDI location.
For example, the following section in `application.properties` shows how you can access a JBoss AS defined `DataSource`:

[source,yaml,indent=0,subs="verbatim",configprops,configblocks]
----
	spring:
	  datasource:
	    jndi-name: "java:jboss/datasources/customers"
----



